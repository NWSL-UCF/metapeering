function [element] = readfileelement(file,latitude,longitude)
%% read the grid element corresponding to the latitude and longitude

ncols = 8640;
nrows = 3432;
cellsize = 2.5/60.0;
xllcorner = -180.0;
yllcorner = -58.0;

%% sanity checks
if (longtitute > 180.0 || longtitute < -180.0 )
    longtitude
    return;
end;
if (latitute > 85.0 || latitute < -58.0 )
    latitude
    element = -1;
    return;
end;

x = ceil( (longtitude-xllcorner)/cellsize ) + 1;
if (x > ncols)
    x = ncols;
end;

y = nrows - ceil( (latitude-yllcorner)/cellsize ); 
if (y == 0)
    y = 0;
end;

fid = fopen(file);
for i=1:(y-1)
    textscan(fid, '%s%*[^\n]');
    element = textscan(fid, '%s %s %f32 %d8 %u %f %f %s');
    if (~strcmp(A(i),C(i)) || ~strcmp(A(i),C(i)))
        match = 0;
    end;
end;

fclose(fid);


if (TOPOLOGY == 1) %% TELSTRA
    %% nodes 108, links 306, Telstra (Australia), BIDIRECTIONAL, DISCONNECTED
    [A, B, latency] = textread('1221/latencies.intra', '%f');
    [C, D, weight] = textread('1221/weights.intra', '%s %s %f');
end;
match

%% CONSTRUCT THE LIST OF ROUTERS IN THE TOPOLOGY
routers(1) = A(1);
for i=2:numoflinks
    %% CHECK FOR MULTIPLE ENTRIES
    if (findfirstarrayelement(routers,A(i)) == 0)
        [routers_size,n] = size(routers);
        routers(routers_size+1,1) = A(i);
    end;
end;
for i=1:numoflinks
    %% CHECK FOR MULTIPLE ENTRIES
    if (findfirstarrayelement(routers,B(i)) == 0)
        [routers_size,n] = size(routers);
        routers(routers_size+1,1) = B(i);
    end;
end;
routers = sort(routers);
routers

%% CONSTRUCT THE ADJACENCY, THE WEIGHT, AND THE LATENCY MATRICES
multiple_links = 0;
[numofnodes,n] = size(routers);
Adj = zeros(numofnodes,numofnodes);
Lat = zeros(numofnodes,numofnodes);
Wei = zeros(numofnodes,numofnodes);
for i=1:numoflinks
    x = findfirstarrayelement(routers,A(i));
    y = findfirstarrayelement(routers,B(i));
    %% CHECK FOR MULTIPLE LINKS
    if (Adj(x,y) == 1)
        multiple_links = multiple_links + 1;
        Adj(x,y)
        multiple_links
    end;
    Adj(x,y) = 1;
    Lat(x,y) = latency(i); 
    Wei(x,y) = weight(i); 
end;

%Adj
numofnodes
numoflinks

%% SANITY CHECK FOR BIDIRECTIONALITY -- 
%% ISP backbone links must be bidirectional
bidirectional = 1;
for i=1:numoflinks
    if (Adj(x,y) == 1)
        if (Adj(y,x) == 0)
            bidirectional = 0;
        end;
    end;
end;
bidirectional
if (bidirectional == 0)
    return;
end;

%% SANITY CHECK FOR CONNECTIVITY
[connected, TC] = TestConnectivity(Adj);
connected
%%[Connectivity, NumofComponents, GlobalRoot, GlobalParent, GlobalCycle]=Dfs(Adj)
%% FIX IF THERE ARE DISJOINT SUBSETS
if (~connected) %% HERE: currently we are just exiting instead of fixing
    return;
end;
 
%% CONSTRUCT THE COST MATRIX
Cost = zeros(numofnodes,numofnodes);
Cost = Wei;
for i=1:numofnodes
    for j=1:numofnodes
        if (Cost(i,j) == 0  &&  i ~= j)
            Cost(i,j) = Inf;
        end;
    end;
end;
%Cost

%% CALCULATE THE ALL PAIRS SHORTEST PATH
%% Floyd-Warshall algorithm
[SP, Prev] = AllPairsShortestPath(Cost);

%% CONSTRUCT THE ROUTING MATRIX
numofflows = numofnodes*numofnodes;
R = zeros(numofflows,numoflinks);
% for all flows..
for i=1:numofnodes
    for j=1:numofnodes
        if (i ~= j)
            flowid = (i-1)*numofnodes + j;
            introuter = Prev(i,j);
            last = j;
            % mark all the links this flow is passing through
            while (introuter ~= i)
                linkid = findlink(routers(introuter),routers(last),A,B);
                if (linkid == 0)
                    linkid
                    introuter
                    routers(introuter)
                    last
                    routers(last)
                end;
                R(flowid,linkid) = 1;
                last = introuter;
                introuter = Prev(i,introuter);
            end;
            % don't forget the very first link this flow traverses
            linkid = findlink(routers(introuter),routers(last),A,B);    
            R(flowid,linkid) = 1;
        end;
    end;
end;

%% FIND LINKS UNUSED DUE TO ROUTING
numofunusedlinks = 0;
for i=1:numoflinks
    if (sum(R(:,i)) == 0)
        numofunusedlinks = numofunusedlinks + 1;
        unusedlinks(numofunusedlinks) = i;
    end;
end;
numofunusedlinks

%% CONSTRUCT THE CAPACITY MATRIX
%% Select the highest degree node and make a BFS. 
%% Assign lower capacity to the links as getting deeper in the BFS tree.
%% find the max degree node
Degrees = zeros(numofnodes,1);
for i=1:numofnodes
    for j=1:numoflinks
        if (strcmp(routers(i),A(j)))
            Degrees(i) = Degrees(i) + 1;
        end;
    end;
end;
%Degrees

%% make BFS starting from the maxdegree node
[maxdegree,maxindices] = max(Degrees);
[Distance,Parent,Layers,NumofLayers]= Bfs(Adj,maxindices(1));
%Distance
%Parent

%% assign capacities to the links (in Mb/s)
capacitylevels = [10000, 2500, 620, 155, 45, 10, 1.5, 1.0];
Capacities = zeros(numoflinks,1);
for i=1:numoflinks
    xid = findfirstarrayelement(routers,A(i));
    yid = findfirstarrayelement(routers,B(i));
    maxdistance = max(Distance(xid),Distance(yid));
    Capacities(i) = capacitylevels(maxdistance);
end;
%Capacities

%% FORM THE TRAFFIC VECTOR FROM THE TRAFFIC MATRIX
%% the set of edge nodes: 1 in the array element indicates edge node
edgenodes = zeros(numofnodes,1);
%% first include all nodes having either degree < 3 or distance > 4
for i=1:numofnodes
    if (Degrees(i) < 3  ||  Distance(i) > 4)
        edgenodes(i) = 1;
    end;
end;

% need to identify the links unused by the current assumption
BeforeTVector = zeros(numofflows,1);
for i=1:numofnodes
    for j=1:numofnodes
        if (i ~= j  &&  edgenodes(i)  &&  edgenodes(j))
            flowid = (i-1)*numofnodes + j;
            %% just assign a traffic of 1 temporarily
            BeforeTVector(flowid) = 1.0;
        end;
    end;
end;
BeforeQ = R' * BeforeTVector;

%% increase the set of edge nodes by including the nodes next to the links 
%% unused by the current set of edge nodes
currunusedlinks = find(BeforeQ <= 0);
[t1,t2] = size(currunusedlinks);
for i=1:t1
    edgenodes(findfirstarrayelement(routers,A(currunusedlinks(i)))) = 1;
    edgenodes(findfirstarrayelement(routers,B(currunusedlinks(i)))) = 1;
end;

%% HERE: just tried assigning all nodes as edge
%% edgenodes = ones(numofnodes,1);

TVector = zeros(numofflows,1);
for i=1:numofnodes
    for j=1:numofnodes
        %% Need to identify edge routers
        %% assumption: edge routers have either degree < 3 or distance > 4
        %% old assumption: each edge-to-edge flow is 0.23Mb/s for Exodus
        %% old assumption: each edge-to-edge flow is 0.0095Mb/s for Ebone
        if (i ~= j  &&  edgenodes(i)  &&  edgenodes(j))
            flowid = (i-1)*numofnodes + j;
            % assign min capacity of all links the flow is
            % traversing
            % TVector(flowid) = 0.23;
            % Need to multiply by MAX_LINK_UTIL so that 100% utilization is
            % avoided.
            TVector(flowid) = MAX_LINK_UTIL*min(Capacities(find(R(flowid,:))));
        end;
    end;
end;

BeforeTVector = TVector;
BeforeQ = R' * BeforeTVector;

feasible = 0;
while (feasible == 0)
    %% nonzero traffic flows
    numofnonzeroflows = size(find(TVector));
    nonzeroflowspercentage = 100*numofnonzeroflows(1) / numofflows;
    nonzeroflowspercentage
    
    %% CALCULATE LOAD ON INDIVIDUAL LINKS
    Q = 0;
    Q = R' * TVector;
    %Q = TVector' * R;
    %Q

    %% CHECK FEASIBILITY
    feasible = 1;
    unfeasiblelinkscount = 0;
    overloads = 0;
    unfeasiblelinks = 0;
    for i=1:numoflinks
        %        if (Q(i) >= Capacities(i))
        %% if (Q(i) ./ Capacities(i) - MAX_LINK_UTIL > 0) %% limit the link utilization
        if (Q(i) ./ Capacities(i) - MAX_LINK_UTIL > 0.01) %% +/- 1% error due to Matlab's precision issues
            feasible = 0;
            %Q(i)
            %Capacities(i)
            
            unfeasiblelinkscount = unfeasiblelinkscount + 1;
            unfeasiblelinks(unfeasiblelinkscount) = i;
            overloads(unfeasiblelinkscount) = Q(i) - Capacities(i);
        end;
    end;
    
    % if not feasible, try to fix it
    if (feasible == 0)
        % find the most overloaded link
        [t1,t2] = max(overloads);
        mostoverloaded = unfeasiblelinks(t2);
        
        if (INFEASIBLE_LINKS == 1)
            % increase the capacity of the link so that the load corresponds to
            % MAX_LINK_UTIL of the link capacity.
            mostoverloaded
            Q(mostoverloaded)
            Capacities(mostoverloaded) = Q(mostoverloaded) ./ MAX_LINK_UTIL;
            Capacities(mostoverloaded)
        elseif (INFEASIBLE_LINKS == 2)
            % if upgrade to the link is possible, then do the minimum necessary upgrade first
            if (capacitylevels(1) > Capacities(mostoverloaded))
                bettercapacitylevels = capacitylevels(find(capacitylevels > Capacities(mostoverloaded)));
                Capacities(mostoverloaded) = min(bettercapacitylevels);
            else
                % calculate the multiplication factor
                factor = Capacities(mostoverloaded) / Q(mostoverloaded)
                %        if (Capacities(mostoverloaded) / Q(mostoverloaded) > MAX_LINK_UTIL)
                if (factor > MAX_LINK_UTIL)
                    factor = MAX_LINK_UTIL
                end;
                % find flows traversing this link
                traversingflows = 0;
                traversingflows = find(R(:,mostoverloaded));
                TVector(traversingflows) = factor * TVector(traversingflows);
            end;
        end;
    end;

end;

%% CALCULATE THE NETWORK'S UTILIZATION
netutilization = 100*sum(Q) / sum(Capacities);
netutilization

%% CALCULATE THE LINK UTILIZATION
linkutilization = 100*sum(Q ./ Capacities) / numoflinks;
linkutilization

%% CALCULATE PER-LINK EXCESS CAPACITY
pkt_size = 1024 %% bytes

%% HERE: SLA requirement for individual links
PathLatencies = zeros(numofflows,1);
for i=1:numofnodes
    for j=1:numofnodes
        if (i ~= j)
            flowid = (i-1)*numofnodes + j;
            PathLatencies(flowid) = sum(R(flowid,:)' .* latency);
        end;
    end;
end;
maxpathlatency = max(PathLatencies);
maxpathlatency

counter = 0;
for E2E_t_avg = E2E_t_avg_range
    counter = counter + 1;
    E2E_t_avg

    unsatisfiedSLA(counter) = 0;
    
    t_avg = zeros(numoflinks,1);
    min_t_avg = zeros(numoflinks,1);
    for i=1:numofnodes
        for j=1:numofnodes
            flowid = (i-1)*numofnodes + j;
            if (i ~= j  &&  TVector(flowid) > 0.0)
                pathlength = sum(R(flowid,:));
                pathlatency = sum(R(flowid,:)' .* latency);
                leftlatency = E2E_t_avg - pathlatency;

                if (leftlatency <= 0.0) %% unsatisfied g2g flow
                    unsatisfiedSLA(counter) = unsatisfiedSLA(counter) + 1;
                end;

                %% go over all links this flow traverses
                linkids = find(R(flowid,:));
                [t1,t2] = size(linkids);
                for k=1:t2
                    linkid = linkids(k);
                    M_D = Capacities(linkid)*1000000.0 / (pkt_size*8.0); %% pkts/s
                    %                min_t_avg = 1.05 * 1.0/M_D; %% min possible t_avg for this link
                    %% HERE HERE: change the (x + 1.0) / M_D below to reduce the
                    %% effect of unsatisfied flows    
                    min_t_avg(linkid) = 1000.0 * ( N_q_mintavg + 1.0)/M_D; %% min possible t_avg for this link (milliseconds)

                    if (leftlatency <= 0.0) %% unsatisfied g2g flow
                        current_t_avg = min_t_avg(linkid);
                    else
                        current_t_avg = max( min_t_avg(linkid), leftlatency/(pathlength) ); %% milliseconds
                    end;

                    if (t_avg(linkid) > 0.0)
                        t_avg(linkid) = min( t_avg(linkid), current_t_avg );
                    else
                        t_avg(linkid) = current_t_avg;
                    end;                
                    t_avg(linkid) = max( min_t_avg(linkid), t_avg(linkid) );
                end;
            end;
        end;
    end;
    %t_avg
    
    unsatisfiedSLA(counter) = 100*unsatisfiedSLA(counter)/numofnonzeroflows(1);
    unsatisfiedSLA(counter);

    %% sanity check for the t_avg values for the links
    for i=1:numoflinks
        if (Q(i) > 0 && t_avg(i) <= 0.0)
            Q(i)
            t_avg(i)
            return;
        end;
    end;

    t_avg = t_avg * 0.001; %% convert to seconds

    ExcessCapacities = zeros(numoflinks,1);
    for i=1:numoflinks
        if (Q(i) > 0) %% && t_avg(i) > 0)
            L_D = Q(i)*1000000.0 / (pkt_size*8.0); %% pkts/s
%            M_N = 1.0/t_avg(i) + L_D; %% M/M/1 model
            M_N = 0.5/t_avg(i) + 1.25*L_D + sqrt(9.0*L_D^2/16.0 - 0.25*L_D/t_avg(i) + 0.25/t_avg(i)^2 ) ; %% MMPP/M/1 model
%            M_N = 0.5/t_avg(i) + 1.25*L_D + sqrt(9.0*L_D^2*t_avg(i)^2 - 4.0*L_D*t_avg(i) + 4.0) / (4.0*t_avg(i)) ; %% MMPP/M/1 model
            ExcessCapacities(i) = max(0, M_N*pkt_size*8.0 / 1000000.0 - Capacities(i)); %% Mb/s 
        end;
    end;

    %% CALCULATE THE REQUIRED AGGREGATE NETWORK EXCESS CAPACITY
    aggregateexcesscapacity(counter) = sum(ExcessCapacities);
    aggregateexcesscapacity(counter)

    aggregateexcesspercentage(counter) = 100 * aggregateexcesscapacity(counter) / sum(Capacities(find(Q>0)));
    aggregateexcesspercentage(counter)

    %% CALCULATE THE REQUIRED AVERAGE LINK EXCESS CAPACITY IN PERCENTAGE
    [t1,t2] = size(find(Q<=0));
    linkexcesscapacitypercentage(counter) = 100.0 * sum(ExcessCapacities ./ Capacities) / (numoflinks-t1);
    linkexcesscapacitypercentage(counter)

end;