%% which topology to use
TOPOLOGY = 5;
%% handling infeasible links: 1 -- JEC, 2 -- MCC
INFEASIBLE_LINKS = 1;
%% minimum number of packets to be assumed at a queue at any link
N_q_mintavg = 1.0;
%% maximum allowed link utilization
MAX_LINK_UTIL = 0.95; %% with +/- 1% error due to precision issues

%% 1 -- random, 2 -- most loaded
LINK_SELECTION = 2;

%% seed for the RNG
rand('seed',11);

%% edge-to-edge delay requirement for premium class traffic (milliseconds)
E2E_t_avg_range = [0.1, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10];

if (TOPOLOGY == 1) %% TELSTRA
    %% nodes 108, links 414, Telstra (Australia), BIDIRECTIONAL, DISCONNECTED
    [A, B, latency] = textread('1221/latencies.intra', '%s %s %f');
    [C, D, weight] = textread('1221/weights.intra', '%s %s %f');
%   %% 64+ is satisfactory
    %% thresholds for edge node selection:
    DEGREETHRESH = 5;
    DISTANCETHRESH = 4;
elseif (TOPOLOGY == 2) %% SPRINTLINK
    %% nodes 315, links 2339, Sprintlink (US), BIDIRECTIONAL, DISCONNECTED
    [A, B, latency] = textread('1239/latencies.intra', '%s %s %f');
    [C, D, weight] = textread('1239/weights.intra', '%s %s %f');
    %% 64+ is satisfactory
    %% thresholds for edge node selection:
    DEGREETHRESH = 9;
    DISTANCETHRESH = 5;
elseif (TOPOLOGY == 3) %% EBONE
    %% nodes 87, links 407, Ebone (Europe), BIDIRECTIONAL, CONNECTED
    [A, B, latency] = textread('1755/latencies.intra', '%s %s %f');
    [C, D, weight] = textread('1755/weights.intra', '%s %s %f');
    %% 57+ is satisfactory
    %% thresholds for edge node selection:
    DEGREETHRESH = 6;
    DISTANCETHRESH = 4;
elseif (TOPOLOGY == 4) %% TISCALI
    %% nodes 161, links 900, Tiscali (Europe), BIDIRECTIONAL, CONNECTED
    [A, B, latency] = textread('3257/latencies.intra', '%s %s %f');
    [C, D, weight] = textread('3257/weights.intra', '%s %s %f');
%   %% 64+ is satisfactory
    %% thresholds for edge node selection:
    DEGREETHRESH = 8;
    DISTANCETHRESH = 4;
elseif (TOPOLOGY == 5) %% EXODUS
    %% nodes 79, links 353, Exodus (US), BIDIRECTIONAL, CONNECTED
    [A, B, latency] = textread('3967/latencies.intra', '%s %s %f');
    [C, D, weight] = textread('3967/weights.intra', '%s %s %f');
    %% 106+ is satisfactory
    %% thresholds for edge node selection:
    DEGREETHRESH = 6;
    DISTANCETHRESH = 4;
elseif (TOPOLOGY == 6) %% ABOVENET
    %% nodes 141, links 925, Abovenet (US), BIDIRECTIONAL, DISCONNECTED
    [A, B, latency] = textread('6461/latencies.intra', '%s %s %f');
    [C, D, weight] = textread('6461/weights.intra', '%s %s %f');
    %% 45+ is satisfactory
    %% thresholds for edge node selection:
    DEGREETHRESH = 9;
    DISTANCETHRESH = 3;
end;

%% utilization levels to be calculated
urange = 0.99:-0.1:0.09;

%% traffic model to be used: 1 -- Poisson, 2 -- MMPP
TRAFFIC_MODEL = 1;
if (TRAFFIC_MODEL == 2) % if MMPP, then set the MMPP parameters
    a_mmpp = 0.5;
    r_mmpp = 4;
end;

%% packet size
pkt_size = 1024 %% bytes

[numoflinks,n] = size(A);

%% CHECK IF THE LATENCY AND WEIGHTS DATA MATCH
match = 1;
for i=1:numoflinks
    if (~strcmp(A(i),C(i)) || ~strcmp(B(i),D(i)))
        match = 0;
    end;
end;
match

%% CONSTRUCT THE LIST OF ROUTERS IN THE TOPOLOGY
routers(1) = A(1);
for i=2:numoflinks
    %% CHECK FOR MULTIPLE ENTRIES
    if (findfirstarrayelement(routers,A(i)) == 0)
        [routers_size,n] = size(routers);
        routers(routers_size+1,1) = A(i);
    end;
end;
for i=1:numoflinks
    %% CHECK FOR MULTIPLE ENTRIES
    if (findfirstarrayelement(routers,B(i)) == 0)
        [routers_size,n] = size(routers);
        routers(routers_size+1,1) = B(i);
    end;
end;
routers = sort(routers);
routers

%% CONSTRUCT THE ADJACENCY, THE WEIGHT, AND THE LATENCY MATRICES
multiple_links = 0;
[numofnodes,n] = size(routers);
Adj = zeros(numofnodes,numofnodes);
Lat = zeros(numofnodes,numofnodes);
Wei = zeros(numofnodes,numofnodes);
for i=1:numoflinks
    x = findfirstarrayelement(routers,A(i));
    y = findfirstarrayelement(routers,B(i));
    %% CHECK FOR MULTIPLE LINKS
    if (Adj(x,y) == 1)
        multiple_links = multiple_links + 1;
        Adj(x,y)
        multiple_links
    end;
    Adj(x,y) = 1;
    Lat(x,y) = latency(i); 
    Wei(x,y) = weight(i); 
end;

%Adj
numofnodes
numoflinks
numofflows = numofnodes*numofnodes;

%% SANITY CHECK FOR BIDIRECTIONALITY -- 
%% ISP backbone links must be bidirectional
bidirectional = 1;
for i=1:numoflinks
    if (Adj(x,y) == 1)
        if (Adj(y,x) == 0)
            bidirectional = 0;
        end;
    end;
end;
bidirectional
if (bidirectional == 0)
    return;
end;

%% SANITY CHECK FOR CONNECTIVITY
% [connected, TC] = TestConnectivity(Adj);
[connected, NumofComponents, GlobalRoot, GlobalParent, GlobalCycle]=Dfs(Adj)
connected
if (~connected) %% HERE: currently we are just exiting instead of fixing
    return;
end;
 
%% CONSTRUCT THE COST MATRIX
Cost = zeros(numofnodes,numofnodes);
Cost = Wei;
for i=1:numofnodes
    for j=1:numofnodes
        if (Cost(i,j) == 0  &&  i ~= j)
            Cost(i,j) = Inf;
        end;
    end;
end;
%Cost


%% CONSTRUCT THE CAPACITY MATRIX
%% Select the highest degree node and make a BFS. 
%% Assign lower capacity to the links as getting deeper in the BFS tree.
%% find the max degree node
Degrees = zeros(numofnodes,1);
for i=1:numofnodes
    for j=1:numoflinks
        if (strcmp(routers(i),A(j)))
            Degrees(i) = Degrees(i) + 1;
        end;
    end;
end;
%Degrees

%% make BFS starting from the maxdegree node
[maxdegree,maxindices] = max(Degrees);
[Distance,Parent,Layers,NumofLayers]= Bfs(Adj,maxindices(1));
%Distance
%Parent

%% assign capacities to the links (in Mb/s)
capacitylevels = [40000, 10000, 2500, 620, 155, 45, 10];
[tempind, numofcapacitylevels] = size(capacitylevels);
Capacities = zeros(numoflinks,1);
for i=1:numoflinks
    xid = findfirstarrayelement(routers,A(i));
    yid = findfirstarrayelement(routers,B(i));
    maxdistance = max(Distance(xid),Distance(yid));
    % assure that no link has less than 10Mb/s capacity
    Capacities(i) = capacitylevels( min(numofcapacitylevels, maxdistance) );
end;
%Capacities

%% FORM THE TRAFFIC VECTOR FROM THE TRAFFIC MATRIX
%% the set of edge nodes: 1 in the array element indicates edge node
edgenodes = zeros(numofnodes,1);
%% first include all nodes having either degree < 3 or distance > 4
for i=1:numofnodes
    if (Degrees(i) < DEGREETHRESH  ||  Distance(i) > DISTANCETHRESH)
        edgenodes(i) = 1;
    end;
end;

% assure that there exists at least one edge router at each city
%edgecities = strrep(strtok(routers(find(edgenodes)), ','), '+', ' ');
topocities = strrep(strtok(routers, ','), '+', ' ');
topocities = strrep(topocities, '0', '');
topocities = strrep(topocities, '1', '');
topocities = strrep(topocities, '2', '');
topocities = strrep(topocities, '3', '');
topocities = strrep(topocities, '4', '');
topocities = strrep(topocities, '5', '');
topocities = strrep(topocities, '6', '');
topocities = strrep(topocities, '7', '');
topocities = strrep(topocities, '8', '');
topocities = strrep(topocities, '9', '');

for i=1:numofnodes
    currentcity = topocities(i);
    if ( sum(edgenodes .* strcmp(topocities, currentcity)) < 1 )
        % need to add a new router to the set of edge nodes
        currentcity
        routerindicesforcurrentcity = find(strcmp(topocities, currentcity));
        % select the max degree router in the city
        [t1, t2] = max(Degrees(routerindicesforcurrentcity));
        maxdegreerouterforcurrentcity = routers(routerindicesforcurrentcity(t2));        
    end;
end;

%return;

% need to identify the links unused by the current assumption
BeforeTVector = zeros(numofflows,1);
for i=1:numofnodes
    for j=1:numofnodes
        if (i ~= j  &&  edgenodes(i)  &&  edgenodes(j))
            flowid = (i-1)*numofnodes + j;
            %% just assign a traffic of 1 temporarily
            BeforeTVector(flowid) = 1.0;
        end;
    end;
end;
%BeforeQ = R' * BeforeTVector;

%% increase the set of edge nodes by including the nodes next to the links 
%% unused by the current set of edge nodes
% currunusedlinks = find(BeforeQ <= 0);
% [t1,t2] = size(currunusedlinks);
% for i=1:t1
%     edgenodes(findfirstarrayelement(routers,A(currunusedlinks(i)))) = 1;
%     edgenodes(findfirstarrayelement(routers,B(currunusedlinks(i)))) = 1;
% end;
% return;

%% HERE: just tried assigning all nodes as edge
%% edgenodes = ones(numofnodes,1);

%%%% Gravity model 

% get the positions of all available cities
[cities, latitudes, longitudes] = textread('cities.txt', '%s %f %f', 'delimiter', '\t' );

% prepare the set of edge cities for the topology under consideration
edgecities = strrep(strtok(routers(find(edgenodes)), ','), '+', ' ');
edgecities = strrep(edgecities, '0', '');
edgecities = strrep(edgecities, '1', '');
edgecities = strrep(edgecities, '2', '');
edgecities = strrep(edgecities, '3', '');
edgecities = strrep(edgecities, '4', '');
edgecities = strrep(edgecities, '5', '');
edgecities = strrep(edgecities, '6', '');
edgecities = strrep(edgecities, '7', '');
edgecities = strrep(edgecities, '8', '');
edgecities = strrep(edgecities, '9', '');

% calculate frequency of each edge city
edgecityfrequencies = 0;
for i=1:sum(edgenodes)
    [t1,t2] = size(find(strcmp(edgecities, edgecities(i))));
    edgecityfrequencies(i) = t1;
end;

% get the populations of all available cities
[populations] = textread('populations.txt', '%f', 'delimiter', '\n' );

% calculate the population of each edge city (divide by the frequency)
edgecitypopulations = 0;
for i=1:sum(edgenodes)
    cityindex = findfirstarrayelement(cities, edgecities(i));
    edgecitypopulations(i) = populations(cityindex);
    edgecitypopulations(i) = edgecitypopulations(i) / edgecityfrequencies(i);

    % sanity check
    if (edgecitypopulations(i) <= 0)
        edgecitypopulations(i)
        return;
    end;
end;
edgecitypopulations

% normalize the edge city populations to their minimum
minpopulation = min(edgecitypopulations);
edgecitymasses = edgecitypopulations ./ minpopulation;

% calculate the gravity product factor for all g2g flows
GravityProducts = zeros(numofflows,1);
for i=1:numofnodes
    for j=1:numofnodes
        flowid = (i-1)*numofnodes + j;
        if (i ~= j  &&  edgenodes(i)  &&  edgenodes(j))
            edgenodei = sum(edgenodes(1:i));
            edgenodej = sum(edgenodes(1:j));
            GravityProducts(flowid) = edgecitymasses(edgenodei) * edgecitymasses(edgenodej);
        else
            GravityProducts(flowid) = Inf;
        end;
    end;
end;
[t1,t2] = size(find(GravityProducts < 1.0));
if (t1 > 0) % sanity check: are there any products less than 1.0?
    t1
    return;
end;

% find the flow with the minimum product factor among all g2g flows
[minprodflow, minprodflowind] = min(GravityProducts);


failurecount = 0;
firstselection = 1;
TempQ = 0;
Q = 0;
while (failurecount < 10) %% BEGIN_WHILE
  
    TempCost = Cost;
    if (failurecount == 0)
        failurecount = failurecount + 1;
    else (failurecount > 0)
        
        TempAdj = Adj;

        if (LINK_SELECTION == 1)
            selectedlink = ceil(rand*numoflinks);
            TempQ = Q;
            [t1,selectedlink] = max(TempQ);
            TempQ(selectedlink) = 0;
            x = findfirstarrayelement(routers,A(selectedlink));
            y = findfirstarrayelement(routers,B(selectedlink));
            TempAdj(x,y) = 0;
            TempAdj(y,x) = 0;
        else
            if (firstselection)
                firstselection = 0;
            else
                TempQ = Q;
                [t1,selectedlink] = max(TempQ);
                TempQ(selectedlink) = 0;
                x = findfirstarrayelement(routers,A(selectedlink));
                y = findfirstarrayelement(routers,B(selectedlink));
                TempAdj(x,y) = 0;
                TempAdj(y,x) = 0;
            end;
        end;

        %% check if the new topology is connected
        [connected, NumofComponents, GlobalRoot, GlobalParent, GlobalCycle]=Dfs(TempAdj)
        connected
        if (~connected) %% if not connected, try failing another link
            continue;
        end;
        TempCost(x,y) = Inf;
        TempCost(y,x) = Inf;

        failurecount = failurecount + 1;
    end;


    %% CALCULATE THE ALL PAIRS SHORTEST PATH
    %% Floyd-Warshall algorithm
    [SP, Prev] = AllPairsShortestPath(TempCost);

    %% CONSTRUCT THE ROUTING MATRIX
    %R = zeros(numofflows,numoflinks,'int8');
    R = zeros(numofflows,numoflinks,'single');
    % for all flows..
    for i=1:numofnodes
        for j=1:numofnodes
            if (i ~= j)
                flowid = (i-1)*numofnodes + j;
                introuter = Prev(i,j);
                last = j;
                % mark all the links this flow is passing through
                count = 0;
                while (introuter ~= i)
                    linkid = findlink(routers(introuter),routers(last),A,B);
                    if (linkid == 0)
                        linkid
                        introuter
                        routers(introuter)
                        last
                        routers(last)
                    end;
                    R(flowid,linkid) = 1;
                    last = introuter;
                    introuter = Prev(i,introuter);

                    count = count + 1;
                    if (count > numofnodes) % there is a loop in routing
                        count
                        return;
                    end;
                end;
                % don't forget the very first link this flow traverses
                linkid = findlink(routers(introuter),routers(last),A,B);
                R(flowid,linkid) = 1;
            end;
        end;
    end;
    

    if (failurecoun
    %% CALCULATE LOAD ON INDIVIDUAL LINKS
            Q = 0;
            Q = R' * TVector;

    

    %% FIND LINKS UNUSED DUE TO ROUTING
    numofunusedlinks = 0;
    for i=1:numoflinks
        if (sum(R(:,i)) == 0)
            numofunusedlinks = numofunusedlinks + 1;
            unusedlinks(numofunusedlinks) = i;
        end;
    end;
    numofunusedlinks

    %% if this is the first time, only then calculate the TM and link
    %% capacities.
    if (failurecount == 1)       
        % find the min-product-factor flow's maximum possible rate
        minflowrate = MAX_LINK_UTIL*min(Capacities(find(R(minprodflowind,:))));

        % calculate rates for all g2g flows based on the min-product-factor flow
        TVector = zeros(numofflows,1);
        for i=1:numofnodes
            for j=1:numofnodes
                %% Need to identify edge routers
                %% assumption: edge routers have either degree < 3 or distance > 4
                %% old assumption: each edge-to-edge flow is 0.23Mb/s for Exodus
                %% old assumption: each edge-to-edge flow is 0.0095Mb/s for Ebone
                if (i ~= j  &&  edgenodes(i)  &&  edgenodes(j))
                    flowid = (i-1)*numofnodes + j;
                    % assign min capacity of all links the flow is
                    % traversing
                    % TVector(flowid) = 0.23;
                    % Need to multiply by MAX_LINK_UTIL so that 100% utilization is
                    % avoided.
                    TVector(flowid) = GravityProducts(flowid)*minflowrate;
                end;
            end;
        end;

        BeforeTVector = TVector;
        BeforeQ = R' * BeforeTVector;

        feasible = 0;
        while (feasible == 0)
            %% nonzero traffic flows
            numofnonzeroflows = size(find(TVector));
            nonzeroflowspercentage = 100*numofnonzeroflows(1) / numofflows;
            nonzeroflowspercentage

            %% CALCULATE LOAD ON INDIVIDUAL LINKS
            Q = 0;
            Q = R' * TVector;
            %Q = TVector' * R;
            %Q

            %% CHECK FEASIBILITY
            feasible = 1;
            unfeasiblelinkscount = 0;
            overloads = 0;
            unfeasiblelinks = 0;
            for i=1:numoflinks
                %        if (Q(i) >= Capacities(i))
                %% if (Q(i) ./ Capacities(i) - MAX_LINK_UTIL > 0) %% limit the link utilization
                if (Q(i) ./ Capacities(i) - MAX_LINK_UTIL > 0.01) %% +/- 1% error due to Matlab's precision issues
                    feasible = 0;
                    %Q(i)
                    %Capacities(i)

                    unfeasiblelinkscount = unfeasiblelinkscount + 1;
                    unfeasiblelinks(unfeasiblelinkscount) = i;
                    overloads(unfeasiblelinkscount) = Q(i) - Capacities(i);
                end;
            end;

            % if not feasible, try to fix it
            if (feasible == 0)
                % find the most overloaded link
                [t1,t2] = max(overloads);
                mostoverloaded = unfeasiblelinks(t2);

                if (INFEASIBLE_LINKS == 1)
                    % increase the capacity of the link so that the load corresponds to
                    % MAX_LINK_UTIL of the link capacity.
                    mostoverloaded
                    Q(mostoverloaded)
                    Capacities(mostoverloaded) = Q(mostoverloaded) ./ MAX_LINK_UTIL;
                    Capacities(mostoverloaded)
                elseif (INFEASIBLE_LINKS == 2)
                    % if upgrade to the link is possible, then do the minimum necessary upgrade first
                    if (capacitylevels(1) > Capacities(mostoverloaded))
                        bettercapacitylevels = capacitylevels(find(capacitylevels > Capacities(mostoverloaded)));
                        Capacities(mostoverloaded) = min(bettercapacitylevels);
                    else
                        % calculate the multiplication factor
                        factor = Capacities(mostoverloaded) / Q(mostoverloaded)
                        %        if (Capacities(mostoverloaded) / Q(mostoverloaded) > MAX_LINK_UTIL)
                        if (factor > MAX_LINK_UTIL)
                            factor = MAX_LINK_UTIL
                        end;
                        % find flows traversing this link
                        traversingflows = 0;
                        traversingflows = find(R(:,mostoverloaded));
                        TVector(traversingflows) = factor * TVector(traversingflows);
                    end;
                end;
            end;

        end;

        if (INFEASIBLE_LINKS == 1)
            % find the largest load per link
            [t1,largestloaded] = max(Q);
            largestload = Q(largestloaded);
            largestloaded
            largestload

            if (capacitylevels(1) < largestload)
                % calculate the multiplication factor
                factor = MAX_LINK_UTIL * capacitylevels(1) / Q(largestloaded);
                if (factor > 1) % this cannot happen
                    factor
                end;
                % scale everybody down
                factor
                TVector = TVector .* factor;
            end;

            %% nonzero traffic flows
            numofnonzeroflows = size(find(TVector));
            nonzeroflowspercentage = 100*numofnonzeroflows(1) / numofflows;
            nonzeroflowspercentage

            %% CALCULATE LOAD ON INDIVIDUAL LINKS
            Q = 0;
            Q = R' * TVector;

            for i=1:numoflinks
                Capacities(i) = max(Capacities(i) .* factor, capacitylevels(numofcapacitylevels));
            end;

            % check feasibility again -- in case
            feasible = 1;
            unfeasiblelinkscount = 0;
            overloads = 0;
            unfeasiblelinks = 0;
            for i=1:numoflinks
                if (Q(i) ./ Capacities(i) - MAX_LINK_UTIL > 0.01) %% +/- 1% error due to Matlab's precision issues
                    feasible = 0;
                    %Q(i)
                    %Capacities(i)

                    unfeasiblelinkscount = unfeasiblelinkscount + 1;
                    unfeasiblelinks(unfeasiblelinkscount) = i;
                    overloads(unfeasiblelinkscount) = Q(i) - Capacities(i);
                end;
            end;
            if (feasible == 0)
                feasible
                return;
            end;
        end;
    
    end;
    %return;

    %% HERE: SLA requirement for individual links
    PathLatencies = zeros(numofflows,1);
    for i=1:numofnodes
        for j=1:numofnodes
            if (i ~= j)
                flowid = (i-1)*numofnodes + j;
                PathLatencies(flowid) = sum(R(flowid,:)' .* latency);
            end;
        end;
    end;
    maxpathlatency = max(PathLatencies);
    maxpathlatency

    saveQ = Q;

    ulevel = 0;
    for u = urange
        ulevel = ulevel + 1;

        Q = 0;
        Q = saveQ*u;
        %% CALCULATE THE NETWORK'S UTILIZATION
        netutilization(ulevel) = 100*sum(Q) / sum(Capacities);
        netutilization(ulevel)

        %% CALCULATE THE LINK UTILIZATION
        linkutilization(ulevel) = 100*sum(Q ./ Capacities) / numoflinks;
        linkutilization(ulevel)

        individuallinkutilization(:,ulevel) = (Q ./ Capacities) * 100;
        individuallinkutilization(:,ulevel)

        %% CALCULATE PER-LINK EXCESS CAPACITY
        counter = 0;
        for E2E_t_avg = E2E_t_avg_range
            counter = counter + 1;
            E2E_t_avg

            unsatisfiedSLA(counter,ulevel) = 0;

            t_avg = zeros(numoflinks,1);
            min_t_avg = zeros(numoflinks,1);
            for i=1:numofnodes
                for j=1:numofnodes
                    flowid = (i-1)*numofnodes + j;
                    if (i ~= j  &&  TVector(flowid) > 0.0)
                        pathlength = sum(R(flowid,:));
                        pathlatency = sum(R(flowid,:)' .* latency);
                        %%leftlatency = E2E_t_avg - pathlatency;
                        leftlatency = E2E_t_avg;

                        if (leftlatency <= 0.0) %% unsatisfied g2g flow
                            unsatisfiedSLA(counter,ulevel) = unsatisfiedSLA(counter,ulevel) + 1;
                        end;

                        %% go over all links this flow traverses
                        linkids = find(R(flowid,:));
                        [t1,t2] = size(linkids);
                        for k=1:t2
                            linkid = linkids(k);
                            M_D = Capacities(linkid)*1000000.0 / (pkt_size*8.0); %% pkts/s
                            %                min_t_avg = 1.05 * 1.0/M_D; %% min possible t_avg for this link
                            %% HERE HERE: change the (x + 1.0) / M_D below to reduce the
                            %% effect of unsatisfied flows
                            min_t_avg(linkid) = 1000.0 * ( N_q_mintavg + 0.0)/M_D; %% min possible t_avg for this link (milliseconds)

                            if (leftlatency <= 0.0) %% unsatisfied g2g flow
                                current_t_avg = min_t_avg(linkid);
                            else
                                current_t_avg = max( min_t_avg(linkid), leftlatency/(pathlength) ); %% milliseconds
                            end;

                            if (t_avg(linkid) > 0.0)
                                t_avg(linkid) = min( t_avg(linkid), current_t_avg );
                            else
                                t_avg(linkid) = current_t_avg;
                            end;
                            t_avg(linkid) = max( min_t_avg(linkid), t_avg(linkid) );
                        end;
                    end;
                end;
            end;
            %t_avg

            unsatisfiedSLA(counter,ulevel) = 100*unsatisfiedSLA(counter,ulevel)/numofnonzeroflows(1);
            unsatisfiedSLA(counter,ulevel);

            %% sanity check for the t_avg values for the links
            for i=1:numoflinks
                if (Q(i) > 0 && t_avg(i) <= 0.0)
                    Q(i)
                    t_avg(i)
                    return;
                end;
            end;

            t_avg = t_avg * 0.001; %% convert to seconds

            gs = zeros(numoflinks,1);
            ExcessCapacities = zeros(numoflinks,1);
            for i=1:numoflinks
                if (Q(i) > 0.0) %% && t_avg(i) > 0)
                    L_D = Q(i)*1000000.0 / (pkt_size*8.0); %% pkts/s
                    if (TRAFFIC_MODEL == 1) %% M/M/1 model
                        M_N = 1.0/t_avg(i) + L_D;
                        ExcessCapacities(i) = max(0, M_N*pkt_size*8.0 / 1000000.0 - Capacities(i)); %% Mb/s
                        M_D = Capacities(i)*1000000.0 / (pkt_size*8.0); %% pkts/s
                        rho = L_D / M_D;
                        % gs(i) = (1+ rho - M_D*t_avg(i)) / (rho - rho*M_D*t_avg(i)); 
                    else %% MMPP/M/1 model
                        M_D = Capacities(i)*1000000.0 / (pkt_size*8.0); %% pkts/s
                        rho = L_D / M_D;
                        t_avg_in_pkts = t_avg(i)*M_D;
                        [rec, g] = getlinkmodelrecvalue(a_mmpp,r_mmpp,rho,t_avg_in_pkts,0);
                        M_N = M_D * (1 + rec/100.0);
                        %M_N = -1/2*(t_avg(i)*L_D+1)*(r_mmpp*t_avg(i)*a_mmpp^2*L_D+a_mmpp^2*r_mmpp-a_mmpp*r_mmpp+t_avg(i)-a_mmpp-sqrt((a_mmpp^2*r_mmpp^2-2*a_mmpp^3*r_mmpp^2-2*r_mmpp^2*t_avg(i)*a_mmpp^3*L_D+r_mmpp^2*t_avg(i)^2*a_mmpp^4*L_D^2+2*r_mmpp^2*t_avg(i)*a_mmpp^4*L_D+a_mmpp^4*r_mmpp^2+2*r_mmpp*t_avg(i)^2*a_mmpp^2*L_D-2*t_avg(i)*a_mmpp*r_mmpp+4*r_mmpp*t_avg(i)*a_mmpp^2*L_D+2*t_avg(i)*a_mmpp^2*r_mmpp+2*a_mmpp^2*r_mmpp-2*a_mmpp^3*r_mmpp-2*r_mmpp*t_avg(i)*a_mmpp^3*L_D+4*t_avg(i)-2*t_avg(i)*a_mmpp+a_mmpp^2+t_avg(i)^2)/a_mmpp^2)*a_mmpp)/t_avg(i);

                        ExcessCapacities(i) = max(0, M_N*pkt_size*8.0 / 1000000.0 - Capacities(i)); %% Mb/s
                        gs(i) = g;
                        %gs(i) = (1+ rho - M_D*t_avg(i)) / (rho - rho*M_D*t_avg(i));
                    end;
                end;
            end;

            %        allgs{counter,ulevel} = sum(gs)/numoflinks; % average g
            allgs{counter,ulevel,failurecount} = gs;

            %% CALCULATE THE REQUIRED AGGREGATE NETWORK EXCESS CAPACITY
            aggregateexcesscapacity(counter,ulevel,failurecount) = sum(ExcessCapacities);
            %        aggregateexcesscapacity(counter,ulevel)

            aggregateexcesspercentage(counter,ulevel,failurecount) = 100 * aggregateexcesscapacity(counter,ulevel) / sum(Capacities(find(Q>0)));
            %        aggregateexcesspercentage(counter,ulevel)

            %% CALCULATE THE REQUIRED AVERAGE LINK EXCESS CAPACITY IN PERCENTAGE
            [t1,t2] = size(find(Q<=0));
            linkexcesscapacitypercentage(counter,ulevel,failurecount) = 100.0 * sum(ExcessCapacities ./ Capacities) / (numoflinks-t1);
            %        linkexcesscapacitypercentage(counter,ulevel)
        end;
        linkexcesscapacitypercentage
        aggregateexcesspercentage

    end;

    %allgs = cell2mat(allgs);

    for i=1:counter
        for j=1:ulevel
            avggs(i,j,failurecount) = sum(min(allgs{i,j,failurecount},1.0))/numoflinks;
        end;
    end;
    
%     fail_linkexcesscapacitypercentage(failurecount) = linkexcesscapacitypercentage;
%     fail_aggregateexcesspercentage(failurecount) = aggregateexcesspercentage;
%     fail_avggs(failurecount) = avggs;

end; %% END_WHILE

%count = 0;
%icount = 0;
%for i=E2E_t_avg_range
%    icount = icount + 1;
%    for j=1:10
%        count = count + 1;
%        x(count) = i;
%        y(count) = linkutilization(j);
%        z(count) = linkexcesscapacitypercentage(icount,j);
%    end;
%end;

%%y = linkutilization;
%%x = E2E_t_avg_range;
%%z = linkexcesscapacitypercentage;

%grid on;
%tri = delaunay(x,y);
%%hold on, triplot(tri,x,y), hold off;
%hidden on;
%trimesh(tri,x,y,z,'LineWidth',1);
%grid on;

%%Thetarange = 0.1:5:170.1; 
%%Prange = 4:4:32; 
%%[XI,YI] = meshgrid(Thetarange,Prange);
%%ZI = griddata(x,y,z,XI,YI);
%%%Plot the gridded data along with the nonuniform data points used to generate it: 
%%mesh(XI,YI,ZI), hold

%ylabel('P -- Source Power (mW)', 'FontSize',12,'FontWeight','bold');
%xlabel('\theta -- Divergence Angle (mRad)', 'FontSize',12,'FontWeight','bold');
%zlabel('I -- Interference Area (m^2)', 'FontSize',12,'FontWeight','bold');

%%xlim([0.5,250]);
%%ylim([4,32]);
%currFig = get(0,'CurrentFigure');
%set(currFig,'Color',[1,1,1]);
